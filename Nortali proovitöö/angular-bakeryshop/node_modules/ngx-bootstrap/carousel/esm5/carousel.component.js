/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
// tslint:disable:max-file-line-count
/***
 * pause (not yet supported) (?string='hover') - event group name which pauses
 * the cycling of the carousel, if hover pauses on mouseenter and resumes on
 * mouseleave keyboard (not yet supported) (?boolean=true) - if false
 * carousel will not react to keyboard events
 * note: swiping not yet supported
 */
/****
 * Problems:
 * 1) if we set an active slide via model changes, .active class remains on a
 * current slide.
 * 2) if we have only one slide, we shouldn't show prev/next nav buttons
 * 3) if first or last slide is active and noWrap is true, there should be
 * "disabled" class on the nav buttons.
 * 4) default interval should be equal 5000
 */
import { Component, EventEmitter, Input, NgZone, Output } from '@angular/core';
import { isBs3, LinkedList } from 'ngx-bootstrap/utils';
import { CarouselConfig } from './carousel.config';
import { findLastIndex, chunkByNumber } from './utils';
/** @enum {number} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["tabindex", "0", 1, "carousel", "slide", 3, "mouseenter", "mouseleave", "mouseup", "keydown", "focusin", "focusout"];
const _c1 = ["class", "carousel-indicators", 4, "ngIf"];
const _c2 = [1, "carousel-inner", 3, "ngStyle"];
const _c3 = ["class", "left carousel-control carousel-control-prev", "tabindex", "0", "role", "button", 3, "disabled", "click", 4, "ngIf"];
const _c4 = ["class", "right carousel-control carousel-control-next", "tabindex", "0", "role", "button", 3, "disabled", "click", 4, "ngIf"];
const _c5 = [1, "carousel-indicators"];
const _c6 = [3, "active", "click", 4, "ngFor", "ngForOf"];
const _c7 = [3, "click"];
function CarouselComponent_ol_1_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r71 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", _c7);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵlistener("click", function CarouselComponent_ol_1_li_1_Template_li_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r71); const i_r69 = ctx.index; const ctx_r70 = ɵngcc0.ɵɵnextContext(2); return ctx_r70.selectSlide(i_r69); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const slidez_r68 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("active", slidez_r68.active === true);
    ɵngcc0.ɵɵstylingApply();
} }
function CarouselComponent_ol_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ol", _c5);
    ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_li_1_Template, 1, 1, "li", _c6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r64 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r64.indicatorsSlides());
} }
const _c8 = ["tabindex", "0", "role", "button", 1, "left", "carousel-control", "carousel-control-prev", 3, "click"];
const _c9 = ["aria-hidden", "true", 1, "icon-prev", "carousel-control-prev-icon"];
const _c10 = ["class", "sr-only", 4, "ngIf"];
const _c11 = [1, "sr-only"];
function CarouselComponent_a_4_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c11);
    ɵngcc0.ɵɵtext(1, "Previous");
    ɵngcc0.ɵɵelementEnd();
} }
function CarouselComponent_a_4_Template(rf, ctx) { if (rf & 1) {
    const _r74 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", _c8);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵlistener("click", function CarouselComponent_a_4_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r74); const ctx_r73 = ɵngcc0.ɵɵnextContext(); return ctx_r73.previousSlide(); });
    ɵngcc0.ɵɵelement(1, "span", _c9);
    ɵngcc0.ɵɵtemplate(2, CarouselComponent_a_4_span_2_Template, 2, 0, "span", _c10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r65 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("disabled", ctx_r65.activeSlide === 0 && ctx_r65.noWrap);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r65.isBs4);
} }
const _c12 = ["tabindex", "0", "role", "button", 1, "right", "carousel-control", "carousel-control-next", 3, "click"];
const _c13 = ["aria-hidden", "true", 1, "icon-next", "carousel-control-next-icon"];
function CarouselComponent_a_5_Template(rf, ctx) { if (rf & 1) {
    const _r76 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", _c12);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵlistener("click", function CarouselComponent_a_5_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r75 = ɵngcc0.ɵɵnextContext(); return ctx_r75.nextSlide(); });
    ɵngcc0.ɵɵelement(1, "span", _c13);
    ɵngcc0.ɵɵelementStart(2, "span", _c11);
    ɵngcc0.ɵɵtext(3, "Next");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r66 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("disabled", ctx_r66.isLast(ctx_r66.activeSlide) && ctx_r66.noWrap);
    ɵngcc0.ɵɵstylingApply();
} }
const _c14 = function (a0) { return { "display": a0 }; };
const _c15 = ["*"];
var Direction = {
    UNKNOWN: 0,
    NEXT: 1,
    PREV: 2,
};
export { Direction };
Direction[Direction.UNKNOWN] = 'UNKNOWN';
Direction[Direction.NEXT] = 'NEXT';
Direction[Direction.PREV] = 'PREV';
/**
 * Base element to create carousel
 */
var CarouselComponent = /** @class */ (function () {
    function CarouselComponent(config, ngZone) {
        this.ngZone = ngZone;
        /* If `true` - carousel indicators indicate slides chunks
             works ONLY if singleSlideOffset = FALSE */
        this.indicatorsByChunk = false;
        /* If value more then 1 — carousel works in multilist mode */
        this.itemsPerSlide = 1;
        /* If `true` — carousel shifts by one element. By default carousel shifts by number
             of visible elements (itemsPerSlide field) */
        this.singleSlideOffset = false;
        /**
         * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property
         */
        this.activeSlideChange = new EventEmitter(false);
        /**
         * Will be emitted when active slides has been changed in multilist mode
         */
        this.slideRangeChange = new EventEmitter();
        /* Index to start display slides from it */
        this.startFromIndex = 0;
        this._slides = new LinkedList();
        this._currentVisibleSlidesIndex = 0;
        this.destroyed = false;
        this.getActive = (/**
         * @param {?} slide
         * @return {?}
         */
        function (slide) { return slide.active; });
        this.makeSlidesConsistent = (/**
         * @param {?} slides
         * @return {?}
         */
        function (slides) {
            slides.forEach((/**
             * @param {?} slide
             * @param {?} index
             * @return {?}
             */
            function (slide, index) { return slide.item.order = index; }));
        });
        Object.assign(this, config);
    }
    Object.defineProperty(CarouselComponent.prototype, "activeSlide", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentActiveSlide;
        },
        /** Index of currently displayed slide(started for 0) */
        set: /**
         * Index of currently displayed slide(started for 0)
         * @param {?} index
         * @return {?}
         */
        function (index) {
            if (this.multilist) {
                return;
            }
            if (this._slides.length && index !== this._currentActiveSlide) {
                this._select(index);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CarouselComponent.prototype, "interval", {
        /**
         * Delay of item cycling in milliseconds. If false, carousel won't cycle
         * automatically.
         */
        get: /**
         * Delay of item cycling in milliseconds. If false, carousel won't cycle
         * automatically.
         * @return {?}
         */
        function () {
            return this._interval;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._interval = value;
            this.restartTimer();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CarouselComponent.prototype, "slides", {
        get: /**
         * @return {?}
         */
        function () {
            return this._slides.toArray();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CarouselComponent.prototype, "isBs4", {
        get: /**
         * @return {?}
         */
        function () {
            return !isBs3();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CarouselComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout((/**
         * @return {?}
         */
        function () {
            if (_this.singleSlideOffset) {
                _this.indicatorsByChunk = false;
            }
            if (_this.multilist) {
                _this._chunkedSlides = chunkByNumber(_this.mapSlidesAndIndexes(), _this.itemsPerSlide);
                _this.selectInitialSlides();
            }
        }), 0);
    };
    /**
     * @return {?}
     */
    CarouselComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroyed = true;
    };
    /**
     * Adds new slide. If this slide is first in collection - set it as active
     * and starts auto changing
     * @param slide
     */
    /**
     * Adds new slide. If this slide is first in collection - set it as active
     * and starts auto changing
     * @param {?} slide
     * @return {?}
     */
    CarouselComponent.prototype.addSlide = /**
     * Adds new slide. If this slide is first in collection - set it as active
     * and starts auto changing
     * @param {?} slide
     * @return {?}
     */
    function (slide) {
        this._slides.add(slide);
        if (this.multilist && this._slides.length <= this.itemsPerSlide) {
            slide.active = true;
        }
        if (!this.multilist && this._slides.length === 1) {
            this._currentActiveSlide = undefined;
            this.activeSlide = 0;
            this.play();
        }
        if (this.multilist && this._slides.length > this.itemsPerSlide) {
            this.play();
        }
    };
    /**
     * Removes specified slide. If this slide is active - will roll to another
     * slide
     * @param slide
     */
    /**
     * Removes specified slide. If this slide is active - will roll to another
     * slide
     * @param {?} slide
     * @return {?}
     */
    CarouselComponent.prototype.removeSlide = /**
     * Removes specified slide. If this slide is active - will roll to another
     * slide
     * @param {?} slide
     * @return {?}
     */
    function (slide) {
        var _this = this;
        /** @type {?} */
        var remIndex = this._slides.indexOf(slide);
        if (this._currentActiveSlide === remIndex) {
            // removing of active slide
            /** @type {?} */
            var nextSlideIndex_1 = void 0;
            if (this._slides.length > 1) {
                // if this slide last - will roll to first slide, if noWrap flag is
                // FALSE or to previous, if noWrap is TRUE in case, if this slide in
                // middle of collection, index of next slide is same to removed
                nextSlideIndex_1 = !this.isLast(remIndex)
                    ? remIndex
                    : this.noWrap ? remIndex - 1 : 0;
            }
            this._slides.remove(remIndex);
            // prevents exception with changing some value after checking
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this._select(nextSlideIndex_1);
            }), 0);
        }
        else {
            this._slides.remove(remIndex);
            /** @type {?} */
            var currentSlideIndex_1 = this.getCurrentSlideIndex();
            setTimeout((/**
             * @return {?}
             */
            function () {
                // after removing, need to actualize index of current active slide
                _this._currentActiveSlide = currentSlideIndex_1;
                _this.activeSlideChange.emit(_this._currentActiveSlide);
            }), 0);
        }
    };
    /**
     * @param {?=} force
     * @return {?}
     */
    CarouselComponent.prototype.nextSlideFromInterval = /**
     * @param {?=} force
     * @return {?}
     */
    function (force) {
        if (force === void 0) { force = false; }
        this.move(Direction.NEXT, force);
    };
    /**
     * Rolling to next slide
     * @param force: {boolean} if true - will ignore noWrap flag
     */
    /**
     * Rolling to next slide
     * @param {?=} force
     * @return {?}
     */
    CarouselComponent.prototype.nextSlide = /**
     * Rolling to next slide
     * @param {?=} force
     * @return {?}
     */
    function (force) {
        if (force === void 0) { force = false; }
        if (this.isPlaying) {
            this.restartTimer();
        }
        this.move(Direction.NEXT, force);
    };
    /**
     * Rolling to previous slide
     * @param force: {boolean} if true - will ignore noWrap flag
     */
    /**
     * Rolling to previous slide
     * @param {?=} force
     * @return {?}
     */
    CarouselComponent.prototype.previousSlide = /**
     * Rolling to previous slide
     * @param {?=} force
     * @return {?}
     */
    function (force) {
        if (force === void 0) { force = false; }
        if (this.isPlaying) {
            this.restartTimer();
        }
        this.move(Direction.PREV, force);
    };
    /**
     * @return {?}
     */
    CarouselComponent.prototype.getFirstVisibleIndex = /**
     * @return {?}
     */
    function () {
        return this.slides.findIndex(this.getActive);
    };
    /**
     * @return {?}
     */
    CarouselComponent.prototype.getLastVisibleIndex = /**
     * @return {?}
     */
    function () {
        return findLastIndex(this.slides, this.getActive);
    };
    /**
     * @param {?} direction
     * @param {?=} force
     * @return {?}
     */
    CarouselComponent.prototype.move = /**
     * @param {?} direction
     * @param {?=} force
     * @return {?}
     */
    function (direction, force) {
        if (force === void 0) { force = false; }
        /** @type {?} */
        var firstVisibleIndex = this.getFirstVisibleIndex();
        /** @type {?} */
        var lastVisibleIndex = this.getLastVisibleIndex();
        if (this.noWrap) {
            if (direction === Direction.NEXT &&
                this.isLast(lastVisibleIndex) ||
                direction === Direction.PREV &&
                    firstVisibleIndex === 0) {
                return;
            }
        }
        if (!this.multilist) {
            this.activeSlide = this.findNextSlideIndex(direction, force);
        }
        else {
            this.moveMultilist(direction);
        }
    };
    /**
     * Swith slides by enter, space and arrows keys
     * @internal
     */
    /**
     * Swith slides by enter, space and arrows keys
     * \@internal
     * @param {?} event
     * @return {?}
     */
    CarouselComponent.prototype.keydownPress = /**
     * Swith slides by enter, space and arrows keys
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // tslint:disable-next-line:deprecation
        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {
            this.nextSlide();
            event.preventDefault();
            return;
        }
        // tslint:disable-next-line:deprecation
        if (event.keyCode === 37 || event.key === 'LeftArrow') {
            this.previousSlide();
            return;
        }
        // tslint:disable-next-line:deprecation
        if (event.keyCode === 39 || event.key === 'RightArrow') {
            this.nextSlide();
            return;
        }
    };
    /**
     * Play on mouse leave
     * @internal
     */
    /**
     * Play on mouse leave
     * \@internal
     * @return {?}
     */
    CarouselComponent.prototype.onMouseLeave = /**
     * Play on mouse leave
     * \@internal
     * @return {?}
     */
    function () {
        if (!this.pauseOnFocus) {
            this.play();
        }
    };
    /**
     * Play on mouse up
     * @internal
     */
    /**
     * Play on mouse up
     * \@internal
     * @return {?}
     */
    CarouselComponent.prototype.onMouseUp = /**
     * Play on mouse up
     * \@internal
     * @return {?}
     */
    function () {
        if (!this.pauseOnFocus) {
            this.play();
        }
    };
    /**
     * When slides on focus autoplay is stopped(optional)
     * @internal
     */
    /**
     * When slides on focus autoplay is stopped(optional)
     * \@internal
     * @return {?}
     */
    CarouselComponent.prototype.pauseFocusIn = /**
     * When slides on focus autoplay is stopped(optional)
     * \@internal
     * @return {?}
     */
    function () {
        if (this.pauseOnFocus) {
            this.isPlaying = false;
            this.resetTimer();
        }
    };
    /**
     * When slides out of focus autoplay is started
     * @internal
     */
    /**
     * When slides out of focus autoplay is started
     * \@internal
     * @return {?}
     */
    CarouselComponent.prototype.pauseFocusOut = /**
     * When slides out of focus autoplay is started
     * \@internal
     * @return {?}
     */
    function () {
        this.play();
    };
    /**
     * Rolling to specified slide
     * @param index: {number} index of slide, which must be shown
     */
    /**
     * Rolling to specified slide
     * @param {?} index
     * @return {?}
     */
    CarouselComponent.prototype.selectSlide = /**
     * Rolling to specified slide
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (this.isPlaying) {
            this.restartTimer();
        }
        if (!this.multilist) {
            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;
        }
        else {
            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);
        }
    };
    /**
     * Starts a auto changing of slides
     */
    /**
     * Starts a auto changing of slides
     * @return {?}
     */
    CarouselComponent.prototype.play = /**
     * Starts a auto changing of slides
     * @return {?}
     */
    function () {
        if (!this.isPlaying) {
            this.isPlaying = true;
            this.restartTimer();
        }
    };
    /**
     * Stops a auto changing of slides
     */
    /**
     * Stops a auto changing of slides
     * @return {?}
     */
    CarouselComponent.prototype.pause = /**
     * Stops a auto changing of slides
     * @return {?}
     */
    function () {
        if (!this.noPause) {
            this.isPlaying = false;
            this.resetTimer();
        }
    };
    /**
     * Finds and returns index of currently displayed slide
     */
    /**
     * Finds and returns index of currently displayed slide
     * @return {?}
     */
    CarouselComponent.prototype.getCurrentSlideIndex = /**
     * Finds and returns index of currently displayed slide
     * @return {?}
     */
    function () {
        return this._slides.findIndex(this.getActive);
    };
    /**
     * Defines, whether the specified index is last in collection
     * @param index
     */
    /**
     * Defines, whether the specified index is last in collection
     * @param {?} index
     * @return {?}
     */
    CarouselComponent.prototype.isLast = /**
     * Defines, whether the specified index is last in collection
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index + 1 >= this._slides.length;
    };
    /**
     * Defines, whether the specified index is first in collection
     * @param index
     */
    /**
     * Defines, whether the specified index is first in collection
     * @param {?} index
     * @return {?}
     */
    CarouselComponent.prototype.isFirst = /**
     * Defines, whether the specified index is first in collection
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index === 0;
    };
    /**
     * @return {?}
     */
    CarouselComponent.prototype.indicatorsSlides = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return this.slides.filter((/**
         * @param {?} slide
         * @param {?} index
         * @return {?}
         */
        function (slide, index) { return !_this.indicatorsByChunk || index % _this.itemsPerSlide === 0; }));
    };
    /**
     * @private
     * @return {?}
     */
    CarouselComponent.prototype.selectInitialSlides = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var startIndex = this.startFromIndex <= this._slides.length
            ? this.startFromIndex
            : 0;
        this.hideSlides();
        if (this.singleSlideOffset) {
            this._slidesWithIndexes = this.mapSlidesAndIndexes();
            if (this._slides.length - startIndex < this.itemsPerSlide) {
                /** @type {?} */
                var slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);
                this._slidesWithIndexes = tslib_1.__spread(this._slidesWithIndexes, slidesToAppend).slice(slidesToAppend.length)
                    .slice(0, this.itemsPerSlide);
            }
            else {
                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);
            }
            this._slidesWithIndexes.forEach((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.item.active = true; }));
            this.makeSlidesConsistent(this._slidesWithIndexes);
        }
        else {
            this.selectRangeByNestedIndex(startIndex);
        }
        this.slideRangeChange.emit(this.getVisibleIndexes());
    };
    /**
     * Defines next slide index, depending of direction
     * @param direction: Direction(UNKNOWN|PREV|NEXT)
     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will
     *   return undefined if next slide require wrapping
     */
    /**
     * Defines next slide index, depending of direction
     * @private
     * @param {?} direction
     * @param {?} force
     * @return {?}
     */
    CarouselComponent.prototype.findNextSlideIndex = /**
     * Defines next slide index, depending of direction
     * @private
     * @param {?} direction
     * @param {?} force
     * @return {?}
     */
    function (direction, force) {
        /** @type {?} */
        var nextSlideIndex = 0;
        if (!force &&
            (this.isLast(this.activeSlide) &&
                direction !== Direction.PREV &&
                this.noWrap)) {
            return undefined;
        }
        switch (direction) {
            case Direction.NEXT:
                // if this is last slide, not force, looping is disabled
                // and need to going forward - select current slide, as a next
                nextSlideIndex = !this.isLast(this._currentActiveSlide)
                    ? this._currentActiveSlide + 1
                    : !force && this.noWrap ? this._currentActiveSlide : 0;
                break;
            case Direction.PREV:
                // if this is first slide, not force, looping is disabled
                // and need to going backward - select current slide, as a next
                nextSlideIndex =
                    this._currentActiveSlide > 0
                        ? this._currentActiveSlide - 1
                        : !force && this.noWrap
                            ? this._currentActiveSlide
                            : this._slides.length - 1;
                break;
            default:
                throw new Error('Unknown direction');
        }
        return nextSlideIndex;
    };
    /**
     * @private
     * @return {?}
     */
    CarouselComponent.prototype.mapSlidesAndIndexes = /**
     * @private
     * @return {?}
     */
    function () {
        return this.slides
            .slice()
            .map((/**
         * @param {?} slide
         * @param {?} index
         * @return {?}
         */
        function (slide, index) {
            return {
                index: index,
                item: slide
            };
        }));
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    CarouselComponent.prototype.selectSlideRange = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (this.isIndexInRange(index)) {
            return;
        }
        this.hideSlides();
        if (!this.singleSlideOffset) {
            this.selectRangeByNestedIndex(index);
        }
        else {
            /** @type {?} */
            var startIndex = this.isIndexOnTheEdges(index)
                ? index
                : index - this.itemsPerSlide + 1;
            /** @type {?} */
            var endIndex = this.isIndexOnTheEdges(index)
                ? index + this.itemsPerSlide
                : index + 1;
            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);
            this.makeSlidesConsistent(this._slidesWithIndexes);
            this._slidesWithIndexes.forEach((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.item.active = true; }));
        }
        this.slideRangeChange.emit(this.getVisibleIndexes());
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    CarouselComponent.prototype.selectRangeByNestedIndex = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var selectedRange = this._chunkedSlides
            .map((/**
         * @param {?} slidesList
         * @param {?} i
         * @return {?}
         */
        function (slidesList, i) {
            return {
                index: i,
                list: slidesList
            };
        }))
            .find((/**
         * @param {?} slidesList
         * @return {?}
         */
        function (slidesList) {
            return slidesList.list.find((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.index === index; })) !== undefined;
        }));
        this._currentVisibleSlidesIndex = selectedRange.index;
        this._chunkedSlides[selectedRange.index].forEach((/**
         * @param {?} slide
         * @return {?}
         */
        function (slide) {
            slide.item.active = true;
        }));
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    CarouselComponent.prototype.isIndexOnTheEdges = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return (index + 1 - this.itemsPerSlide <= 0 ||
            index + this.itemsPerSlide <= this._slides.length);
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    CarouselComponent.prototype.isIndexInRange = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (this.singleSlideOffset) {
            /** @type {?} */
            var visibleIndexes = this._slidesWithIndexes.map((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.index; }));
            return visibleIndexes.indexOf(index) >= 0;
        }
        return (index <= this.getLastVisibleIndex() &&
            index >= this.getFirstVisibleIndex());
    };
    /**
     * @private
     * @return {?}
     */
    CarouselComponent.prototype.hideSlides = /**
     * @private
     * @return {?}
     */
    function () {
        this.slides.forEach((/**
         * @param {?} slide
         * @return {?}
         */
        function (slide) { return slide.active = false; }));
    };
    /**
     * @private
     * @return {?}
     */
    CarouselComponent.prototype.isVisibleSlideListLast = /**
     * @private
     * @return {?}
     */
    function () {
        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;
    };
    /**
     * @private
     * @return {?}
     */
    CarouselComponent.prototype.isVisibleSlideListFirst = /**
     * @private
     * @return {?}
     */
    function () {
        return this._currentVisibleSlidesIndex === 0;
    };
    /**
     * @private
     * @param {?} direction
     * @return {?}
     */
    CarouselComponent.prototype.moveSliderByOneItem = /**
     * @private
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        /** @type {?} */
        var firstVisibleIndex;
        /** @type {?} */
        var lastVisibleIndex;
        /** @type {?} */
        var indexToHide;
        /** @type {?} */
        var indexToShow;
        if (this.noWrap) {
            firstVisibleIndex = this.getFirstVisibleIndex();
            lastVisibleIndex = this.getLastVisibleIndex();
            indexToHide = direction === Direction.NEXT
                ? firstVisibleIndex
                : lastVisibleIndex;
            indexToShow = direction !== Direction.NEXT
                ? firstVisibleIndex - 1
                : !this.isLast(lastVisibleIndex)
                    ? lastVisibleIndex + 1 : 0;
            this._slides.get(indexToHide).active = false;
            this._slides.get(indexToShow).active = true;
            /** @type {?} */
            var slidesToReorder = this.mapSlidesAndIndexes().filter((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.item.active; }));
            this.makeSlidesConsistent(slidesToReorder);
            this.slideRangeChange.emit(this.getVisibleIndexes());
        }
        else {
            /** @type {?} */
            var displayedIndex = void 0;
            firstVisibleIndex = this._slidesWithIndexes[0].index;
            lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;
            if (direction === Direction.NEXT) {
                this._slidesWithIndexes.shift();
                displayedIndex = this.isLast(lastVisibleIndex)
                    ? 0
                    : lastVisibleIndex + 1;
                this._slidesWithIndexes.push({
                    index: displayedIndex,
                    item: this._slides.get(displayedIndex)
                });
            }
            else {
                this._slidesWithIndexes.pop();
                displayedIndex = this.isFirst(firstVisibleIndex)
                    ? this._slides.length - 1
                    : firstVisibleIndex - 1;
                this._slidesWithIndexes = tslib_1.__spread([{
                        index: displayedIndex,
                        item: this._slides.get(displayedIndex)
                    }], this._slidesWithIndexes);
            }
            this.hideSlides();
            this._slidesWithIndexes.forEach((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.item.active = true; }));
            this.makeSlidesConsistent(this._slidesWithIndexes);
            this.slideRangeChange.emit(this._slidesWithIndexes.map((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.index; })));
        }
    };
    /**
     * @private
     * @param {?} direction
     * @return {?}
     */
    CarouselComponent.prototype.moveMultilist = /**
     * @private
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        if (this.singleSlideOffset) {
            this.moveSliderByOneItem(direction);
        }
        else {
            this.hideSlides();
            if (this.noWrap) {
                this._currentVisibleSlidesIndex = direction === Direction.NEXT
                    ? this._currentVisibleSlidesIndex + 1
                    : this._currentVisibleSlidesIndex - 1;
            }
            else {
                if (direction === Direction.NEXT) {
                    this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()
                        ? 0
                        : this._currentVisibleSlidesIndex + 1;
                }
                else {
                    this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst()
                        ? this._chunkedSlides.length - 1
                        : this._currentVisibleSlidesIndex - 1;
                }
            }
            this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.item.active = true; }));
            this.slideRangeChange.emit(this.getVisibleIndexes());
        }
    };
    /**
     * @private
     * @return {?}
     */
    CarouselComponent.prototype.getVisibleIndexes = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.singleSlideOffset) {
            return this._chunkedSlides[this._currentVisibleSlidesIndex]
                .map((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.index; }));
        }
        else {
            return this._slidesWithIndexes.map((/**
             * @param {?} slide
             * @return {?}
             */
            function (slide) { return slide.index; }));
        }
    };
    /**
     * Sets a slide, which specified through index, as active
     * @param index
     */
    /**
     * Sets a slide, which specified through index, as active
     * @private
     * @param {?} index
     * @return {?}
     */
    CarouselComponent.prototype._select = /**
     * Sets a slide, which specified through index, as active
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (isNaN(index)) {
            this.pause();
            return;
        }
        if (!this.multilist) {
            /** @type {?} */
            var currentSlide = this._slides.get(this._currentActiveSlide);
            if (currentSlide) {
                currentSlide.active = false;
            }
        }
        /** @type {?} */
        var nextSlide = this._slides.get(index);
        if (nextSlide) {
            this._currentActiveSlide = index;
            nextSlide.active = true;
            this.activeSlide = index;
            this.activeSlideChange.emit(index);
        }
    };
    /**
     * Starts loop of auto changing of slides
     */
    /**
     * Starts loop of auto changing of slides
     * @private
     * @return {?}
     */
    CarouselComponent.prototype.restartTimer = /**
     * Starts loop of auto changing of slides
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.resetTimer();
        /** @type {?} */
        var interval = +this.interval;
        if (!isNaN(interval) && interval > 0) {
            this.currentInterval = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return setInterval((/**
                 * @return {?}
                 */
                function () {
                    /** @type {?} */
                    var nInterval = +_this.interval;
                    _this.ngZone.run((/**
                     * @return {?}
                     */
                    function () {
                        if (_this.isPlaying &&
                            !isNaN(_this.interval) &&
                            nInterval > 0 &&
                            _this.slides.length) {
                            _this.nextSlideFromInterval();
                        }
                        else {
                            _this.pause();
                        }
                    }));
                }), interval);
            }));
        }
    };
    Object.defineProperty(CarouselComponent.prototype, "multilist", {
        get: /**
         * @return {?}
         */
        function () {
            return this.itemsPerSlide > 1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Stops loop of auto changing of slides
     */
    /**
     * Stops loop of auto changing of slides
     * @private
     * @return {?}
     */
    CarouselComponent.prototype.resetTimer = /**
     * Stops loop of auto changing of slides
     * @private
     * @return {?}
     */
    function () {
        if (this.currentInterval) {
            clearInterval(this.currentInterval);
            this.currentInterval = void 0;
        }
    };
    /** @nocollapse */
    CarouselComponent.ctorParameters = function () { return [
        { type: CarouselConfig },
        { type: NgZone }
    ]; };
    CarouselComponent.propDecorators = {
        noWrap: [{ type: Input }],
        noPause: [{ type: Input }],
        showIndicators: [{ type: Input }],
        pauseOnFocus: [{ type: Input }],
        indicatorsByChunk: [{ type: Input }],
        itemsPerSlide: [{ type: Input }],
        singleSlideOffset: [{ type: Input }],
        activeSlideChange: [{ type: Output }],
        slideRangeChange: [{ type: Output }],
        activeSlide: [{ type: Input }],
        startFromIndex: [{ type: Input }],
        interval: [{ type: Input }]
    };
CarouselComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: CarouselComponent, selectors: [["carousel"]], factory: function CarouselComponent_Factory(t) { return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselConfig), ɵngcc0.ɵɵdirectiveInject(NgZone)); }, inputs: { indicatorsByChunk: "indicatorsByChunk", itemsPerSlide: "itemsPerSlide", singleSlideOffset: "singleSlideOffset", startFromIndex: "startFromIndex", activeSlide: "activeSlide", interval: "interval", noWrap: "noWrap", noPause: "noPause", showIndicators: "showIndicators", pauseOnFocus: "pauseOnFocus" }, outputs: { activeSlideChange: "activeSlideChange", slideRangeChange: "slideRangeChange" }, ngContentSelectors: _c15, consts: 6, vars: 6, template: function CarouselComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", _c0);
        ɵngcc0.ɵɵlistener("mouseenter", function CarouselComponent_Template_div_mouseenter_0_listener($event) { return ctx.pause(); });
        ɵngcc0.ɵɵlistener("mouseleave", function CarouselComponent_Template_div_mouseleave_0_listener($event) { return ctx.onMouseLeave(); });
        ɵngcc0.ɵɵlistener("mouseup", function CarouselComponent_Template_div_mouseup_0_listener($event) { return ctx.onMouseUp(); });
        ɵngcc0.ɵɵlistener("keydown", function CarouselComponent_Template_div_keydown_0_listener($event) { return ctx.keydownPress($event); });
        ɵngcc0.ɵɵlistener("focusin", function CarouselComponent_Template_div_focusin_0_listener($event) { return ctx.pauseFocusIn(); });
        ɵngcc0.ɵɵlistener("focusout", function CarouselComponent_Template_div_focusout_0_listener($event) { return ctx.pauseFocusOut(); });
        ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_Template, 2, 1, "ol", _c1);
        ɵngcc0.ɵɵelementStart(2, "div", _c2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, CarouselComponent_a_4_Template, 3, 2, "a", _c3);
        ɵngcc0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 1, "a", _c4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showIndicators && ctx.slides.length > 1);
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(4, _c14, ctx.multilist ? "flex" : "block"));
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.slides.length > 1);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.slides.length > 1);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgStyle, ɵngcc1.NgForOf], encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(CarouselComponent, [{
        type: Component,
        args: [{
                selector: 'carousel',
                template: "<div (mouseenter)=\"pause()\" (mouseleave)=\"onMouseLeave()\" (mouseup)=\"onMouseUp()\" class=\"carousel slide\" (keydown)=\"keydownPress($event)\" (focusin)=\"pauseFocusIn()\" (focusout)=\"pauseFocusOut()\" tabindex=\"0\">\n  <ol class=\"carousel-indicators\" *ngIf=\"showIndicators && slides.length > 1\">\n    <li *ngFor=\"let slidez of indicatorsSlides(); let i = index;\" [class.active]=\"slidez.active === true\" (click)=\"selectSlide(i)\"></li>\n  </ol>\n  <div class=\"carousel-inner\" [ngStyle]=\"{'display': multilist ? 'flex' : 'block'}\"><ng-content></ng-content></div>\n  <a class=\"left carousel-control carousel-control-prev\" [class.disabled]=\"activeSlide === 0 && noWrap\" (click)=\"previousSlide()\" *ngIf=\"slides.length > 1\"\n      tabindex=\"0\" role=\"button\">\n    <span class=\"icon-prev carousel-control-prev-icon\" aria-hidden=\"true\"></span>\n    <span *ngIf=\"isBs4\" class=\"sr-only\">Previous</span>\n  </a>\n  <a class=\"right carousel-control carousel-control-next\" (click)=\"nextSlide()\" [class.disabled]=\"isLast(activeSlide) && noWrap\" *ngIf=\"slides.length > 1\"\n     tabindex=\"0\" role=\"button\">\n    <span class=\"icon-next carousel-control-next-icon\" aria-hidden=\"true\"></span>\n    <span class=\"sr-only\">Next</span>\n  </a>\n</div>\n"
            }]
    }], function () { return [{ type: CarouselConfig }, { type: NgZone }]; }, { ngZone: [], indicatorsByChunk: [{
            type: Input
        }], itemsPerSlide: [{
            type: Input
        }], singleSlideOffset: [{
            type: Input
        }], activeSlideChange: [{
            type: Output
        }], slideRangeChange: [{
            type: Output
        }], startFromIndex: [{
            type: Input
        }], _slides: [], _currentVisibleSlidesIndex: [], destroyed: [], getActive: [], makeSlidesConsistent: [], activeSlide: [{
            type: Input
        }], activeSlide: [], interval: [{
            type: Input
        }], interval: [], slides: [], isBs4: [], ngAfterViewInit: [], ngOnDestroy: [], addSlide: [], _currentActiveSlide: [], removeSlide: [], nextSlideFromInterval: [], nextSlide: [], previousSlide: [], getFirstVisibleIndex: [], getLastVisibleIndex: [], move: [], keydownPress: [], onMouseLeave: [], onMouseUp: [], pauseFocusIn: [], isPlaying: [], pauseFocusOut: [], selectSlide: [], play: [], pause: [], getCurrentSlideIndex: [], isLast: [], isFirst: [], indicatorsSlides: [], selectInitialSlides: [], _slidesWithIndexes: [], findNextSlideIndex: [], mapSlidesAndIndexes: [], selectSlideRange: [], selectRangeByNestedIndex: [], isIndexOnTheEdges: [], isIndexInRange: [], hideSlides: [], isVisibleSlideListLast: [], isVisibleSlideListFirst: [], moveSliderByOneItem: [], moveMultilist: [], getVisibleIndexes: [], _select: [], restartTimer: [], currentInterval: [], multilist: [], resetTimer: [], noWrap: [{
            type: Input
        }], noPause: [{
            type: Input
        }], showIndicators: [{
            type: Input
        }], pauseOnFocus: [{
            type: Input
        }] });
    return CarouselComponent;
}());
export { CarouselComponent };
if (false) {
    /** @type {?} */
    CarouselComponent.prototype.noWrap;
    /** @type {?} */
    CarouselComponent.prototype.noPause;
    /** @type {?} */
    CarouselComponent.prototype.showIndicators;
    /** @type {?} */
    CarouselComponent.prototype.pauseOnFocus;
    /** @type {?} */
    CarouselComponent.prototype.indicatorsByChunk;
    /** @type {?} */
    CarouselComponent.prototype.itemsPerSlide;
    /** @type {?} */
    CarouselComponent.prototype.singleSlideOffset;
    /**
     * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property
     * @type {?}
     */
    CarouselComponent.prototype.activeSlideChange;
    /**
     * Will be emitted when active slides has been changed in multilist mode
     * @type {?}
     */
    CarouselComponent.prototype.slideRangeChange;
    /** @type {?} */
    CarouselComponent.prototype.startFromIndex;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype.currentInterval;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype._currentActiveSlide;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype._interval;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype._slides;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype._chunkedSlides;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype._slidesWithIndexes;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype._currentVisibleSlidesIndex;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype.isPlaying;
    /**
     * @type {?}
     * @protected
     */
    CarouselComponent.prototype.destroyed;
    /** @type {?} */
    CarouselComponent.prototype.getActive;
    /**
     * @type {?}
     * @private
     */
    CarouselComponent.prototype.makeSlidesConsistent;
    /**
     * @type {?}
     * @private
     */
    CarouselComponent.prototype.ngZone;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL2Fhcm9uL09uZURyaXZlL0Rlc2t0b3AvQW5ndWxhci0wNi0yMDIyLTIvTm9ydGFsaSBwcm9vdml0w7bDti9hbmd1bGFyLWJha2VyeXNob3Avbm9kZV9tb2R1bGVzL25neC1ib290c3RyYXAvY2Fyb3VzZWwvZXNtNS9jYXJvdXNlbC5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUEwa0NNLEFBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0FtQkEiLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtZmlsZS1saW5lLWNvdW50XG4vKioqXG4gKiBwYXVzZSAobm90IHlldCBzdXBwb3J0ZWQpICg/c3RyaW5nPSdob3ZlcicpIC0gZXZlbnQgZ3JvdXAgbmFtZSB3aGljaCBwYXVzZXNcbiAqIHRoZSBjeWNsaW5nIG9mIHRoZSBjYXJvdXNlbCwgaWYgaG92ZXIgcGF1c2VzIG9uIG1vdXNlZW50ZXIgYW5kIHJlc3VtZXMgb25cbiAqIG1vdXNlbGVhdmUga2V5Ym9hcmQgKG5vdCB5ZXQgc3VwcG9ydGVkKSAoP2Jvb2xlYW49dHJ1ZSkgLSBpZiBmYWxzZVxuICogY2Fyb3VzZWwgd2lsbCBub3QgcmVhY3QgdG8ga2V5Ym9hcmQgZXZlbnRzXG4gKiBub3RlOiBzd2lwaW5nIG5vdCB5ZXQgc3VwcG9ydGVkXG4gKi9cbi8qKioqXG4gKiBQcm9ibGVtczpcbiAqIDEpIGlmIHdlIHNldCBhbiBhY3RpdmUgc2xpZGUgdmlhIG1vZGVsIGNoYW5nZXMsIC5hY3RpdmUgY2xhc3MgcmVtYWlucyBvbiBhXG4gKiBjdXJyZW50IHNsaWRlLlxuICogMikgaWYgd2UgaGF2ZSBvbmx5IG9uZSBzbGlkZSwgd2Ugc2hvdWxkbid0IHNob3cgcHJldi9uZXh0IG5hdiBidXR0b25zXG4gKiAzKSBpZiBmaXJzdCBvciBsYXN0IHNsaWRlIGlzIGFjdGl2ZSBhbmQgbm9XcmFwIGlzIHRydWUsIHRoZXJlIHNob3VsZCBiZVxuICogXCJkaXNhYmxlZFwiIGNsYXNzIG9uIHRoZSBuYXYgYnV0dG9ucy5cbiAqIDQpIGRlZmF1bHQgaW50ZXJ2YWwgc2hvdWxkIGJlIGVxdWFsIDUwMDBcbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBOZ1pvbmUsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNCczMsIExpbmtlZExpc3QgfSBmcm9tICduZ3gtYm9vdHN0cmFwL3V0aWxzJztcbmltcG9ydCB7IENhcm91c2VsQ29uZmlnIH0gZnJvbSAnLi9jYXJvdXNlbC5jb25maWcnO1xuaW1wb3J0IHsgZmluZExhc3RJbmRleCwgY2h1bmtCeU51bWJlciB9IGZyb20gJy4vdXRpbHMnO1xuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG52YXIgRGlyZWN0aW9uID0ge1xuICAgIFVOS05PV046IDAsXG4gICAgTkVYVDogMSxcbiAgICBQUkVWOiAyLFxufTtcbmV4cG9ydCB7IERpcmVjdGlvbiB9O1xuRGlyZWN0aW9uW0RpcmVjdGlvbi5VTktOT1dOXSA9ICdVTktOT1dOJztcbkRpcmVjdGlvbltEaXJlY3Rpb24uTkVYVF0gPSAnTkVYVCc7XG5EaXJlY3Rpb25bRGlyZWN0aW9uLlBSRVZdID0gJ1BSRVYnO1xuLyoqXG4gKiBCYXNlIGVsZW1lbnQgdG8gY3JlYXRlIGNhcm91c2VsXG4gKi9cbnZhciBDYXJvdXNlbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXJvdXNlbENvbXBvbmVudChjb25maWcsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgLyogSWYgYHRydWVgIC0gY2Fyb3VzZWwgaW5kaWNhdG9ycyBpbmRpY2F0ZSBzbGlkZXMgY2h1bmtzXG4gICAgICAgICAgICAgd29ya3MgT05MWSBpZiBzaW5nbGVTbGlkZU9mZnNldCA9IEZBTFNFICovXG4gICAgICAgIHRoaXMuaW5kaWNhdG9yc0J5Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgLyogSWYgdmFsdWUgbW9yZSB0aGVuIDEg4oCUIGNhcm91c2VsIHdvcmtzIGluIG11bHRpbGlzdCBtb2RlICovXG4gICAgICAgIHRoaXMuaXRlbXNQZXJTbGlkZSA9IDE7XG4gICAgICAgIC8qIElmIGB0cnVlYCDigJQgY2Fyb3VzZWwgc2hpZnRzIGJ5IG9uZSBlbGVtZW50LiBCeSBkZWZhdWx0IGNhcm91c2VsIHNoaWZ0cyBieSBudW1iZXJcbiAgICAgICAgICAgICBvZiB2aXNpYmxlIGVsZW1lbnRzIChpdGVtc1BlclNsaWRlIGZpZWxkKSAqL1xuICAgICAgICB0aGlzLnNpbmdsZVNsaWRlT2Zmc2V0ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGJlIGVtaXR0ZWQgd2hlbiBhY3RpdmUgc2xpZGUgaGFzIGJlZW4gY2hhbmdlZC4gUGFydCBvZiB0d28td2F5LWJpbmRhYmxlIFsoYWN0aXZlU2xpZGUpXSBwcm9wZXJ0eVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVTbGlkZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBiZSBlbWl0dGVkIHdoZW4gYWN0aXZlIHNsaWRlcyBoYXMgYmVlbiBjaGFuZ2VkIGluIG11bHRpbGlzdCBtb2RlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNsaWRlUmFuZ2VDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qIEluZGV4IHRvIHN0YXJ0IGRpc3BsYXkgc2xpZGVzIGZyb20gaXQgKi9cbiAgICAgICAgdGhpcy5zdGFydEZyb21JbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3NsaWRlcyA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRWaXNpYmxlU2xpZGVzSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdldEFjdGl2ZSA9ICgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHNsaWRlKSB7IHJldHVybiBzbGlkZS5hY3RpdmU7IH0pO1xuICAgICAgICB0aGlzLm1ha2VTbGlkZXNDb25zaXN0ZW50ID0gKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNsaWRlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHNsaWRlcykge1xuICAgICAgICAgICAgc2xpZGVzLmZvckVhY2goKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHNsaWRlLCBpbmRleCkgeyByZXR1cm4gc2xpZGUuaXRlbS5vcmRlciA9IGluZGV4OyB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlU2xpZGVcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRBY3RpdmVTbGlkZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEluZGV4IG9mIGN1cnJlbnRseSBkaXNwbGF5ZWQgc2xpZGUoc3RhcnRlZCBmb3IgMCkgKi9cbiAgICAgICAgc2V0OiAvKipcbiAgICAgICAgICogSW5kZXggb2YgY3VycmVudGx5IGRpc3BsYXllZCBzbGlkZShzdGFydGVkIGZvciAwKVxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpbGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zbGlkZXMubGVuZ3RoICYmIGluZGV4ICE9PSB0aGlzLl9jdXJyZW50QWN0aXZlU2xpZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLCBcImludGVydmFsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGF5IG9mIGl0ZW0gY3ljbGluZyBpbiBtaWxsaXNlY29uZHMuIElmIGZhbHNlLCBjYXJvdXNlbCB3b24ndCBjeWNsZVxuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogRGVsYXkgb2YgaXRlbSBjeWNsaW5nIGluIG1pbGxpc2Vjb25kcy4gSWYgZmFsc2UsIGNhcm91c2VsIHdvbid0IGN5Y2xlXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2xpZGVzXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zbGlkZXMudG9BcnJheSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLCBcImlzQnM0XCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNCczMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNpbmdsZVNsaWRlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5kaWNhdG9yc0J5Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5tdWx0aWxpc3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2h1bmtlZFNsaWRlcyA9IGNodW5rQnlOdW1iZXIoX3RoaXMubWFwU2xpZGVzQW5kSW5kZXhlcygpLCBfdGhpcy5pdGVtc1BlclNsaWRlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RJbml0aWFsU2xpZGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IHNsaWRlLiBJZiB0aGlzIHNsaWRlIGlzIGZpcnN0IGluIGNvbGxlY3Rpb24gLSBzZXQgaXQgYXMgYWN0aXZlXG4gICAgICogYW5kIHN0YXJ0cyBhdXRvIGNoYW5naW5nXG4gICAgICogQHBhcmFtIHNsaWRlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgc2xpZGUuIElmIHRoaXMgc2xpZGUgaXMgZmlyc3QgaW4gY29sbGVjdGlvbiAtIHNldCBpdCBhcyBhY3RpdmVcbiAgICAgKiBhbmQgc3RhcnRzIGF1dG8gY2hhbmdpbmdcbiAgICAgKiBAcGFyYW0gez99IHNsaWRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuYWRkU2xpZGUgPSAvKipcbiAgICAgKiBBZGRzIG5ldyBzbGlkZS4gSWYgdGhpcyBzbGlkZSBpcyBmaXJzdCBpbiBjb2xsZWN0aW9uIC0gc2V0IGl0IGFzIGFjdGl2ZVxuICAgICAqIGFuZCBzdGFydHMgYXV0byBjaGFuZ2luZ1xuICAgICAqIEBwYXJhbSB7P30gc2xpZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzbGlkZSkge1xuICAgICAgICB0aGlzLl9zbGlkZXMuYWRkKHNsaWRlKTtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlsaXN0ICYmIHRoaXMuX3NsaWRlcy5sZW5ndGggPD0gdGhpcy5pdGVtc1BlclNsaWRlKSB7XG4gICAgICAgICAgICBzbGlkZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tdWx0aWxpc3QgJiYgdGhpcy5fc2xpZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGl2ZVNsaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTbGlkZSA9IDA7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tdWx0aWxpc3QgJiYgdGhpcy5fc2xpZGVzLmxlbmd0aCA+IHRoaXMuaXRlbXNQZXJTbGlkZSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgc3BlY2lmaWVkIHNsaWRlLiBJZiB0aGlzIHNsaWRlIGlzIGFjdGl2ZSAtIHdpbGwgcm9sbCB0byBhbm90aGVyXG4gICAgICogc2xpZGVcbiAgICAgKiBAcGFyYW0gc2xpZGVcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHNwZWNpZmllZCBzbGlkZS4gSWYgdGhpcyBzbGlkZSBpcyBhY3RpdmUgLSB3aWxsIHJvbGwgdG8gYW5vdGhlclxuICAgICAqIHNsaWRlXG4gICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZVNsaWRlID0gLyoqXG4gICAgICogUmVtb3ZlcyBzcGVjaWZpZWQgc2xpZGUuIElmIHRoaXMgc2xpZGUgaXMgYWN0aXZlIC0gd2lsbCByb2xsIHRvIGFub3RoZXJcbiAgICAgKiBzbGlkZVxuICAgICAqIEBwYXJhbSB7P30gc2xpZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzbGlkZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciByZW1JbmRleCA9IHRoaXMuX3NsaWRlcy5pbmRleE9mKHNsaWRlKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBY3RpdmVTbGlkZSA9PT0gcmVtSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92aW5nIG9mIGFjdGl2ZSBzbGlkZVxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIG5leHRTbGlkZUluZGV4XzEgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2xpZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIHNsaWRlIGxhc3QgLSB3aWxsIHJvbGwgdG8gZmlyc3Qgc2xpZGUsIGlmIG5vV3JhcCBmbGFnIGlzXG4gICAgICAgICAgICAgICAgLy8gRkFMU0Ugb3IgdG8gcHJldmlvdXMsIGlmIG5vV3JhcCBpcyBUUlVFIGluIGNhc2UsIGlmIHRoaXMgc2xpZGUgaW5cbiAgICAgICAgICAgICAgICAvLyBtaWRkbGUgb2YgY29sbGVjdGlvbiwgaW5kZXggb2YgbmV4dCBzbGlkZSBpcyBzYW1lIHRvIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBuZXh0U2xpZGVJbmRleF8xID0gIXRoaXMuaXNMYXN0KHJlbUluZGV4KVxuICAgICAgICAgICAgICAgICAgICA/IHJlbUluZGV4XG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5ub1dyYXAgPyByZW1JbmRleCAtIDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2xpZGVzLnJlbW92ZShyZW1JbmRleCk7XG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBleGNlcHRpb24gd2l0aCBjaGFuZ2luZyBzb21lIHZhbHVlIGFmdGVyIGNoZWNraW5nXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2VsZWN0KG5leHRTbGlkZUluZGV4XzEpO1xuICAgICAgICAgICAgfSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2xpZGVzLnJlbW92ZShyZW1JbmRleCk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgY3VycmVudFNsaWRlSW5kZXhfMSA9IHRoaXMuZ2V0Q3VycmVudFNsaWRlSW5kZXgoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHJlbW92aW5nLCBuZWVkIHRvIGFjdHVhbGl6ZSBpbmRleCBvZiBjdXJyZW50IGFjdGl2ZSBzbGlkZVxuICAgICAgICAgICAgICAgIF90aGlzLl9jdXJyZW50QWN0aXZlU2xpZGUgPSBjdXJyZW50U2xpZGVJbmRleF8xO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZVNsaWRlQ2hhbmdlLmVtaXQoX3RoaXMuX2N1cnJlbnRBY3RpdmVTbGlkZSk7XG4gICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGZvcmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUubmV4dFNsaWRlRnJvbUludGVydmFsID0gLyoqXG4gICAgICogQHBhcmFtIHs/PX0gZm9yY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMubW92ZShEaXJlY3Rpb24uTkVYVCwgZm9yY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUm9sbGluZyB0byBuZXh0IHNsaWRlXG4gICAgICogQHBhcmFtIGZvcmNlOiB7Ym9vbGVhbn0gaWYgdHJ1ZSAtIHdpbGwgaWdub3JlIG5vV3JhcCBmbGFnXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUm9sbGluZyB0byBuZXh0IHNsaWRlXG4gICAgICogQHBhcmFtIHs/PX0gZm9yY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5uZXh0U2xpZGUgPSAvKipcbiAgICAgKiBSb2xsaW5nIHRvIG5leHQgc2xpZGVcbiAgICAgKiBAcGFyYW0gez89fSBmb3JjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZShEaXJlY3Rpb24uTkVYVCwgZm9yY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUm9sbGluZyB0byBwcmV2aW91cyBzbGlkZVxuICAgICAqIEBwYXJhbSBmb3JjZToge2Jvb2xlYW59IGlmIHRydWUgLSB3aWxsIGlnbm9yZSBub1dyYXAgZmxhZ1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJvbGxpbmcgdG8gcHJldmlvdXMgc2xpZGVcbiAgICAgKiBAcGFyYW0gez89fSBmb3JjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLnByZXZpb3VzU2xpZGUgPSAvKipcbiAgICAgKiBSb2xsaW5nIHRvIHByZXZpb3VzIHNsaWRlXG4gICAgICogQHBhcmFtIHs/PX0gZm9yY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmUoRGlyZWN0aW9uLlBSRVYsIGZvcmNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLmdldEZpcnN0VmlzaWJsZUluZGV4ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWRlcy5maW5kSW5kZXgodGhpcy5nZXRBY3RpdmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGFzdFZpc2libGVJbmRleCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmluZExhc3RJbmRleCh0aGlzLnNsaWRlcywgdGhpcy5nZXRBY3RpdmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0gez89fSBmb3JjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLm1vdmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGZvcmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGlyZWN0aW9uLCBmb3JjZSkge1xuICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGZpcnN0VmlzaWJsZUluZGV4ID0gdGhpcy5nZXRGaXJzdFZpc2libGVJbmRleCgpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBsYXN0VmlzaWJsZUluZGV4ID0gdGhpcy5nZXRMYXN0VmlzaWJsZUluZGV4KCk7XG4gICAgICAgIGlmICh0aGlzLm5vV3JhcCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5FWFQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmlzTGFzdChsYXN0VmlzaWJsZUluZGV4KSB8fFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlBSRVYgJiZcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RWaXNpYmxlSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpbGlzdCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTbGlkZSA9IHRoaXMuZmluZE5leHRTbGlkZUluZGV4KGRpcmVjdGlvbiwgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlTXVsdGlsaXN0KGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN3aXRoIHNsaWRlcyBieSBlbnRlciwgc3BhY2UgYW5kIGFycm93cyBrZXlzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU3dpdGggc2xpZGVzIGJ5IGVudGVyLCBzcGFjZSBhbmQgYXJyb3dzIGtleXNcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5rZXlkb3duUHJlc3MgPSAvKipcbiAgICAgKiBTd2l0aCBzbGlkZXMgYnkgZW50ZXIsIHNwYWNlIGFuZCBhcnJvd3Mga2V5c1xuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkZXByZWNhdGlvblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgfHwgZXZlbnQua2V5ID09PSAnRW50ZXInIHx8IGV2ZW50LmtleUNvZGUgPT09IDMyIHx8IGV2ZW50LmtleSA9PT0gJ1NwYWNlJykge1xuICAgICAgICAgICAgdGhpcy5uZXh0U2xpZGUoKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAzNyB8fCBldmVudC5rZXkgPT09ICdMZWZ0QXJyb3cnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzU2xpZGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDM5IHx8IGV2ZW50LmtleSA9PT0gJ1JpZ2h0QXJyb3cnKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTbGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQbGF5IG9uIG1vdXNlIGxlYXZlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUGxheSBvbiBtb3VzZSBsZWF2ZVxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gLyoqXG4gICAgICogUGxheSBvbiBtb3VzZSBsZWF2ZVxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXVzZU9uRm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQbGF5IG9uIG1vdXNlIHVwXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUGxheSBvbiBtb3VzZSB1cFxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUub25Nb3VzZVVwID0gLyoqXG4gICAgICogUGxheSBvbiBtb3VzZSB1cFxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXVzZU9uRm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHNsaWRlcyBvbiBmb2N1cyBhdXRvcGxheSBpcyBzdG9wcGVkKG9wdGlvbmFsKVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFdoZW4gc2xpZGVzIG9uIGZvY3VzIGF1dG9wbGF5IGlzIHN0b3BwZWQob3B0aW9uYWwpXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5wYXVzZUZvY3VzSW4gPSAvKipcbiAgICAgKiBXaGVuIHNsaWRlcyBvbiBmb2N1cyBhdXRvcGxheSBpcyBzdG9wcGVkKG9wdGlvbmFsKVxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlT25Gb2N1cykge1xuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRUaW1lcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHNsaWRlcyBvdXQgb2YgZm9jdXMgYXV0b3BsYXkgaXMgc3RhcnRlZFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFdoZW4gc2xpZGVzIG91dCBvZiBmb2N1cyBhdXRvcGxheSBpcyBzdGFydGVkXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5wYXVzZUZvY3VzT3V0ID0gLyoqXG4gICAgICogV2hlbiBzbGlkZXMgb3V0IG9mIGZvY3VzIGF1dG9wbGF5IGlzIHN0YXJ0ZWRcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJvbGxpbmcgdG8gc3BlY2lmaWVkIHNsaWRlXG4gICAgICogQHBhcmFtIGluZGV4OiB7bnVtYmVyfSBpbmRleCBvZiBzbGlkZSwgd2hpY2ggbXVzdCBiZSBzaG93blxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJvbGxpbmcgdG8gc3BlY2lmaWVkIHNsaWRlXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLnNlbGVjdFNsaWRlID0gLyoqXG4gICAgICogUm9sbGluZyB0byBzcGVjaWZpZWQgc2xpZGVcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tdWx0aWxpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU2xpZGUgPSB0aGlzLmluZGljYXRvcnNCeUNodW5rID8gaW5kZXggKiB0aGlzLml0ZW1zUGVyU2xpZGUgOiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0U2xpZGVSYW5nZSh0aGlzLmluZGljYXRvcnNCeUNodW5rID8gaW5kZXggKiB0aGlzLml0ZW1zUGVyU2xpZGUgOiBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIGF1dG8gY2hhbmdpbmcgb2Ygc2xpZGVzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5wbGF5ID0gLyoqXG4gICAgICogU3RhcnRzIGEgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUGxheWluZykge1xuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcHMgYSBhdXRvIGNoYW5naW5nIG9mIHNsaWRlc1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFN0b3BzIGEgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5wYXVzZSA9IC8qKlxuICAgICAqIFN0b3BzIGEgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vUGF1c2UpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgYW5kIHJldHVybnMgaW5kZXggb2YgY3VycmVudGx5IGRpc3BsYXllZCBzbGlkZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGFuZCByZXR1cm5zIGluZGV4IG9mIGN1cnJlbnRseSBkaXNwbGF5ZWQgc2xpZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDdXJyZW50U2xpZGVJbmRleCA9IC8qKlxuICAgICAqIEZpbmRzIGFuZCByZXR1cm5zIGluZGV4IG9mIGN1cnJlbnRseSBkaXNwbGF5ZWQgc2xpZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWRlcy5maW5kSW5kZXgodGhpcy5nZXRBY3RpdmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVmaW5lcywgd2hldGhlciB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIGxhc3QgaW4gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIERlZmluZXMsIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBsYXN0IGluIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuaXNMYXN0ID0gLyoqXG4gICAgICogRGVmaW5lcywgd2hldGhlciB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIGxhc3QgaW4gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggKyAxID49IHRoaXMuX3NsaWRlcy5sZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzLCB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgZmlyc3QgaW4gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIERlZmluZXMsIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBmaXJzdCBpbiBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLmlzRmlyc3QgPSAvKipcbiAgICAgKiBEZWZpbmVzLCB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgZmlyc3QgaW4gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5pbmRpY2F0b3JzU2xpZGVzID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWRlcy5maWx0ZXIoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNsaWRlXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChzbGlkZSwgaW5kZXgpIHsgcmV0dXJuICFfdGhpcy5pbmRpY2F0b3JzQnlDaHVuayB8fCBpbmRleCAlIF90aGlzLml0ZW1zUGVyU2xpZGUgPT09IDA7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuc2VsZWN0SW5pdGlhbFNsaWRlcyA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLnN0YXJ0RnJvbUluZGV4IDw9IHRoaXMuX3NsaWRlcy5sZW5ndGhcbiAgICAgICAgICAgID8gdGhpcy5zdGFydEZyb21JbmRleFxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB0aGlzLmhpZGVTbGlkZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlU2xpZGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzID0gdGhpcy5tYXBTbGlkZXNBbmRJbmRleGVzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2xpZGVzLmxlbmd0aCAtIHN0YXJ0SW5kZXggPCB0aGlzLml0ZW1zUGVyU2xpZGUpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlc1RvQXBwZW5kID0gdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXMuc2xpY2UoMCwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXMgPSB0c2xpYl8xLl9fc3ByZWFkKHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzLCBzbGlkZXNUb0FwcGVuZCkuc2xpY2Uoc2xpZGVzVG9BcHBlbmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgdGhpcy5pdGVtc1BlclNsaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzID0gdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXMuc2xpY2Uoc3RhcnRJbmRleCwgc3RhcnRJbmRleCArIHRoaXMuaXRlbXNQZXJTbGlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zbGlkZXNXaXRoSW5kZXhlcy5mb3JFYWNoKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gc2xpZGVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChzbGlkZSkgeyByZXR1cm4gc2xpZGUuaXRlbS5hY3RpdmUgPSB0cnVlOyB9KSk7XG4gICAgICAgICAgICB0aGlzLm1ha2VTbGlkZXNDb25zaXN0ZW50KHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0UmFuZ2VCeU5lc3RlZEluZGV4KHN0YXJ0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVSYW5nZUNoYW5nZS5lbWl0KHRoaXMuZ2V0VmlzaWJsZUluZGV4ZXMoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIG5leHQgc2xpZGUgaW5kZXgsIGRlcGVuZGluZyBvZiBkaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uOiBEaXJlY3Rpb24oVU5LTk9XTnxQUkVWfE5FWFQpXG4gICAgICogQHBhcmFtIGZvcmNlOiB7Ym9vbGVhbn0gaWYgVFJVRSAtIHdpbGwgaWdub3JlIG5vV3JhcCBmbGFnLCBlbHNlIHdpbGxcbiAgICAgKiAgIHJldHVybiB1bmRlZmluZWQgaWYgbmV4dCBzbGlkZSByZXF1aXJlIHdyYXBwaW5nXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBuZXh0IHNsaWRlIGluZGV4LCBkZXBlbmRpbmcgb2YgZGlyZWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gZm9yY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5maW5kTmV4dFNsaWRlSW5kZXggPSAvKipcbiAgICAgKiBEZWZpbmVzIG5leHQgc2xpZGUgaW5kZXgsIGRlcGVuZGluZyBvZiBkaXJlY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBmb3JjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRpcmVjdGlvbiwgZm9yY2UpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgbmV4dFNsaWRlSW5kZXggPSAwO1xuICAgICAgICBpZiAoIWZvcmNlICYmXG4gICAgICAgICAgICAodGhpcy5pc0xhc3QodGhpcy5hY3RpdmVTbGlkZSkgJiZcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gIT09IERpcmVjdGlvbi5QUkVWICYmXG4gICAgICAgICAgICAgICAgdGhpcy5ub1dyYXApKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIERpcmVjdGlvbi5ORVhUOlxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbGFzdCBzbGlkZSwgbm90IGZvcmNlLCBsb29waW5nIGlzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgLy8gYW5kIG5lZWQgdG8gZ29pbmcgZm9yd2FyZCAtIHNlbGVjdCBjdXJyZW50IHNsaWRlLCBhcyBhIG5leHRcbiAgICAgICAgICAgICAgICBuZXh0U2xpZGVJbmRleCA9ICF0aGlzLmlzTGFzdCh0aGlzLl9jdXJyZW50QWN0aXZlU2xpZGUpXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fY3VycmVudEFjdGl2ZVNsaWRlICsgMVxuICAgICAgICAgICAgICAgICAgICA6ICFmb3JjZSAmJiB0aGlzLm5vV3JhcCA/IHRoaXMuX2N1cnJlbnRBY3RpdmVTbGlkZSA6IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERpcmVjdGlvbi5QUkVWOlxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgZmlyc3Qgc2xpZGUsIG5vdCBmb3JjZSwgbG9vcGluZyBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIC8vIGFuZCBuZWVkIHRvIGdvaW5nIGJhY2t3YXJkIC0gc2VsZWN0IGN1cnJlbnQgc2xpZGUsIGFzIGEgbmV4dFxuICAgICAgICAgICAgICAgIG5leHRTbGlkZUluZGV4ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGl2ZVNsaWRlID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9jdXJyZW50QWN0aXZlU2xpZGUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICFmb3JjZSAmJiB0aGlzLm5vV3JhcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5fY3VycmVudEFjdGl2ZVNsaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0U2xpZGVJbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUubWFwU2xpZGVzQW5kSW5kZXhlcyA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWRlc1xuICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgIC5tYXAoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNsaWRlXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChzbGlkZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIGl0ZW06IHNsaWRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5zZWxlY3RTbGlkZVJhbmdlID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmRleEluUmFuZ2UoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaWRlU2xpZGVzKCk7XG4gICAgICAgIGlmICghdGhpcy5zaW5nbGVTbGlkZU9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RSYW5nZUJ5TmVzdGVkSW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLmlzSW5kZXhPblRoZUVkZ2VzKGluZGV4KVxuICAgICAgICAgICAgICAgID8gaW5kZXhcbiAgICAgICAgICAgICAgICA6IGluZGV4IC0gdGhpcy5pdGVtc1BlclNsaWRlICsgMTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMuaXNJbmRleE9uVGhlRWRnZXMoaW5kZXgpXG4gICAgICAgICAgICAgICAgPyBpbmRleCArIHRoaXMuaXRlbXNQZXJTbGlkZVxuICAgICAgICAgICAgICAgIDogaW5kZXggKyAxO1xuICAgICAgICAgICAgdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXMgPSB0aGlzLm1hcFNsaWRlc0FuZEluZGV4ZXMoKS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgICAgICB0aGlzLm1ha2VTbGlkZXNDb25zaXN0ZW50KHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzKTtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzLmZvckVhY2goKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHNsaWRlKSB7IHJldHVybiBzbGlkZS5pdGVtLmFjdGl2ZSA9IHRydWU7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNsaWRlUmFuZ2VDaGFuZ2UuZW1pdCh0aGlzLmdldFZpc2libGVJbmRleGVzKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuc2VsZWN0UmFuZ2VCeU5lc3RlZEluZGV4ID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHRoaXMuX2NodW5rZWRTbGlkZXNcbiAgICAgICAgICAgIC5tYXAoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNsaWRlc0xpc3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBpXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoc2xpZGVzTGlzdCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBsaXN0OiBzbGlkZXNMaXN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5maW5kKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzbGlkZXNMaXN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoc2xpZGVzTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNsaWRlc0xpc3QubGlzdC5maW5kKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gc2xpZGVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChzbGlkZSkgeyByZXR1cm4gc2xpZGUuaW5kZXggPT09IGluZGV4OyB9KSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl9jdXJyZW50VmlzaWJsZVNsaWRlc0luZGV4ID0gc2VsZWN0ZWRSYW5nZS5pbmRleDtcbiAgICAgICAgdGhpcy5fY2h1bmtlZFNsaWRlc1tzZWxlY3RlZFJhbmdlLmluZGV4XS5mb3JFYWNoKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgICAgICBzbGlkZS5pdGVtLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLmlzSW5kZXhPblRoZUVkZ2VzID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleCArIDEgLSB0aGlzLml0ZW1zUGVyU2xpZGUgPD0gMCB8fFxuICAgICAgICAgICAgaW5kZXggKyB0aGlzLml0ZW1zUGVyU2xpZGUgPD0gdGhpcy5fc2xpZGVzLmxlbmd0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5pc0luZGV4SW5SYW5nZSA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVNsaWRlT2Zmc2V0KSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgdmlzaWJsZUluZGV4ZXMgPSB0aGlzLl9zbGlkZXNXaXRoSW5kZXhlcy5tYXAoKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHNsaWRlKSB7IHJldHVybiBzbGlkZS5pbmRleDsgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHZpc2libGVJbmRleGVzLmluZGV4T2YoaW5kZXgpID49IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpbmRleCA8PSB0aGlzLmdldExhc3RWaXNpYmxlSW5kZXgoKSAmJlxuICAgICAgICAgICAgaW5kZXggPj0gdGhpcy5nZXRGaXJzdFZpc2libGVJbmRleCgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuaGlkZVNsaWRlcyA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2goKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNsaWRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoc2xpZGUpIHsgcmV0dXJuIHNsaWRlLmFjdGl2ZSA9IGZhbHNlOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLmlzVmlzaWJsZVNsaWRlTGlzdExhc3QgPSAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFZpc2libGVTbGlkZXNJbmRleCA9PT0gdGhpcy5fY2h1bmtlZFNsaWRlcy5sZW5ndGggLSAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5pc1Zpc2libGVTbGlkZUxpc3RGaXJzdCA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VmlzaWJsZVNsaWRlc0luZGV4ID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLm1vdmVTbGlkZXJCeU9uZUl0ZW0gPSAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGZpcnN0VmlzaWJsZUluZGV4O1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBsYXN0VmlzaWJsZUluZGV4O1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBpbmRleFRvSGlkZTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgaW5kZXhUb1Nob3c7XG4gICAgICAgIGlmICh0aGlzLm5vV3JhcCkge1xuICAgICAgICAgICAgZmlyc3RWaXNpYmxlSW5kZXggPSB0aGlzLmdldEZpcnN0VmlzaWJsZUluZGV4KCk7XG4gICAgICAgICAgICBsYXN0VmlzaWJsZUluZGV4ID0gdGhpcy5nZXRMYXN0VmlzaWJsZUluZGV4KCk7XG4gICAgICAgICAgICBpbmRleFRvSGlkZSA9IGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5FWFRcbiAgICAgICAgICAgICAgICA/IGZpcnN0VmlzaWJsZUluZGV4XG4gICAgICAgICAgICAgICAgOiBsYXN0VmlzaWJsZUluZGV4O1xuICAgICAgICAgICAgaW5kZXhUb1Nob3cgPSBkaXJlY3Rpb24gIT09IERpcmVjdGlvbi5ORVhUXG4gICAgICAgICAgICAgICAgPyBmaXJzdFZpc2libGVJbmRleCAtIDFcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzTGFzdChsYXN0VmlzaWJsZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICA/IGxhc3RWaXNpYmxlSW5kZXggKyAxIDogMDtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlcy5nZXQoaW5kZXhUb0hpZGUpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc2xpZGVzLmdldChpbmRleFRvU2hvdykuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBzbGlkZXNUb1Jlb3JkZXIgPSB0aGlzLm1hcFNsaWRlc0FuZEluZGV4ZXMoKS5maWx0ZXIoKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHNsaWRlKSB7IHJldHVybiBzbGlkZS5pdGVtLmFjdGl2ZTsgfSkpO1xuICAgICAgICAgICAgdGhpcy5tYWtlU2xpZGVzQ29uc2lzdGVudChzbGlkZXNUb1Jlb3JkZXIpO1xuICAgICAgICAgICAgdGhpcy5zbGlkZVJhbmdlQ2hhbmdlLmVtaXQodGhpcy5nZXRWaXNpYmxlSW5kZXhlcygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBkaXNwbGF5ZWRJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZpcnN0VmlzaWJsZUluZGV4ID0gdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXNbMF0uaW5kZXg7XG4gICAgICAgICAgICBsYXN0VmlzaWJsZUluZGV4ID0gdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXNbdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXMubGVuZ3RoIC0gMV0uaW5kZXg7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTkVYVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgZGlzcGxheWVkSW5kZXggPSB0aGlzLmlzTGFzdChsYXN0VmlzaWJsZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiBsYXN0VmlzaWJsZUluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zbGlkZXNXaXRoSW5kZXhlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGRpc3BsYXllZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiB0aGlzLl9zbGlkZXMuZ2V0KGRpc3BsYXllZEluZGV4KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZGlzcGxheWVkSW5kZXggPSB0aGlzLmlzRmlyc3QoZmlyc3RWaXNpYmxlSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fc2xpZGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgOiBmaXJzdFZpc2libGVJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXMgPSB0c2xpYl8xLl9fc3ByZWFkKFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZGlzcGxheWVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiB0aGlzLl9zbGlkZXMuZ2V0KGRpc3BsYXllZEluZGV4KVxuICAgICAgICAgICAgICAgICAgICB9XSwgdGhpcy5fc2xpZGVzV2l0aEluZGV4ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oaWRlU2xpZGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9zbGlkZXNXaXRoSW5kZXhlcy5mb3JFYWNoKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gc2xpZGVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChzbGlkZSkgeyByZXR1cm4gc2xpZGUuaXRlbS5hY3RpdmUgPSB0cnVlOyB9KSk7XG4gICAgICAgICAgICB0aGlzLm1ha2VTbGlkZXNDb25zaXN0ZW50KHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzKTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVSYW5nZUNoYW5nZS5lbWl0KHRoaXMuX3NsaWRlc1dpdGhJbmRleGVzLm1hcCgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHNsaWRlXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoc2xpZGUpIHsgcmV0dXJuIHNsaWRlLmluZGV4OyB9KSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUubW92ZU11bHRpbGlzdCA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlU2xpZGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVNsaWRlckJ5T25lSXRlbShkaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlU2xpZGVzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ub1dyYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VmlzaWJsZVNsaWRlc0luZGV4ID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTkVYVFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX2N1cnJlbnRWaXNpYmxlU2xpZGVzSW5kZXggKyAxXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3VycmVudFZpc2libGVTbGlkZXNJbmRleCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTkVYVCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VmlzaWJsZVNsaWRlc0luZGV4ID0gdGhpcy5pc1Zpc2libGVTbGlkZUxpc3RMYXN0KClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdXJyZW50VmlzaWJsZVNsaWRlc0luZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRWaXNpYmxlU2xpZGVzSW5kZXggPSB0aGlzLmlzVmlzaWJsZVNsaWRlTGlzdEZpcnN0KClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5fY2h1bmtlZFNsaWRlcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N1cnJlbnRWaXNpYmxlU2xpZGVzSW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NodW5rZWRTbGlkZXNbdGhpcy5fY3VycmVudFZpc2libGVTbGlkZXNJbmRleF0uZm9yRWFjaCgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHNsaWRlXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoc2xpZGUpIHsgcmV0dXJuIHNsaWRlLml0ZW0uYWN0aXZlID0gdHJ1ZTsgfSkpO1xuICAgICAgICAgICAgdGhpcy5zbGlkZVJhbmdlQ2hhbmdlLmVtaXQodGhpcy5nZXRWaXNpYmxlSW5kZXhlcygpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWaXNpYmxlSW5kZXhlcyA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaW5nbGVTbGlkZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rZWRTbGlkZXNbdGhpcy5fY3VycmVudFZpc2libGVTbGlkZXNJbmRleF1cbiAgICAgICAgICAgICAgICAubWFwKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gc2xpZGVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChzbGlkZSkgeyByZXR1cm4gc2xpZGUuaW5kZXg7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zbGlkZXNXaXRoSW5kZXhlcy5tYXAoKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHNsaWRlKSB7IHJldHVybiBzbGlkZS5pbmRleDsgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc2xpZGUsIHdoaWNoIHNwZWNpZmllZCB0aHJvdWdoIGluZGV4LCBhcyBhY3RpdmVcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc2xpZGUsIHdoaWNoIHNwZWNpZmllZCB0aHJvdWdoIGluZGV4LCBhcyBhY3RpdmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5fc2VsZWN0ID0gLyoqXG4gICAgICogU2V0cyBhIHNsaWRlLCB3aGljaCBzcGVjaWZpZWQgdGhyb3VnaCBpbmRleCwgYXMgYWN0aXZlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGlzTmFOKGluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tdWx0aWxpc3QpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBjdXJyZW50U2xpZGUgPSB0aGlzLl9zbGlkZXMuZ2V0KHRoaXMuX2N1cnJlbnRBY3RpdmVTbGlkZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNsaWRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNsaWRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIG5leHRTbGlkZSA9IHRoaXMuX3NsaWRlcy5nZXQoaW5kZXgpO1xuICAgICAgICBpZiAobmV4dFNsaWRlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aXZlU2xpZGUgPSBpbmRleDtcbiAgICAgICAgICAgIG5leHRTbGlkZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTbGlkZSA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTbGlkZUNoYW5nZS5lbWl0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGxvb3Agb2YgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTdGFydHMgbG9vcCBvZiBhdXRvIGNoYW5naW5nIG9mIHNsaWRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUucmVzdGFydFRpbWVyID0gLyoqXG4gICAgICogU3RhcnRzIGxvb3Agb2YgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc2V0VGltZXIoKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSArdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbnRlcnZhbCA9IHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW50ZXJ2YWwoKC8qKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBuSW50ZXJ2YWwgPSArX3RoaXMuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5nWm9uZS5ydW4oKC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzUGxheWluZyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc05hTihfdGhpcy5pbnRlcnZhbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuSW50ZXJ2YWwgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5leHRTbGlkZUZyb21JbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibXVsdGlsaXN0XCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zUGVyU2xpZGUgPiAxO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTdG9wcyBsb29wIG9mIGF1dG8gY2hhbmdpbmcgb2Ygc2xpZGVzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU3RvcHMgbG9vcCBvZiBhdXRvIGNoYW5naW5nIG9mIHNsaWRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUucmVzZXRUaW1lciA9IC8qKlxuICAgICAqIFN0b3BzIGxvb3Agb2YgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jdXJyZW50SW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhcm91c2VsQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Nhcm91c2VsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiAobW91c2VlbnRlcik9XFxcInBhdXNlKClcXFwiIChtb3VzZWxlYXZlKT1cXFwib25Nb3VzZUxlYXZlKClcXFwiIChtb3VzZXVwKT1cXFwib25Nb3VzZVVwKClcXFwiIGNsYXNzPVxcXCJjYXJvdXNlbCBzbGlkZVxcXCIgKGtleWRvd24pPVxcXCJrZXlkb3duUHJlc3MoJGV2ZW50KVxcXCIgKGZvY3VzaW4pPVxcXCJwYXVzZUZvY3VzSW4oKVxcXCIgKGZvY3Vzb3V0KT1cXFwicGF1c2VGb2N1c091dCgpXFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+XFxuICA8b2wgY2xhc3M9XFxcImNhcm91c2VsLWluZGljYXRvcnNcXFwiICpuZ0lmPVxcXCJzaG93SW5kaWNhdG9ycyAmJiBzbGlkZXMubGVuZ3RoID4gMVxcXCI+XFxuICAgIDxsaSAqbmdGb3I9XFxcImxldCBzbGlkZXogb2YgaW5kaWNhdG9yc1NsaWRlcygpOyBsZXQgaSA9IGluZGV4O1xcXCIgW2NsYXNzLmFjdGl2ZV09XFxcInNsaWRlei5hY3RpdmUgPT09IHRydWVcXFwiIChjbGljayk9XFxcInNlbGVjdFNsaWRlKGkpXFxcIj48L2xpPlxcbiAgPC9vbD5cXG4gIDxkaXYgY2xhc3M9XFxcImNhcm91c2VsLWlubmVyXFxcIiBbbmdTdHlsZV09XFxcInsnZGlzcGxheSc6IG11bHRpbGlzdCA/ICdmbGV4JyA6ICdibG9jayd9XFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XFxuICA8YSBjbGFzcz1cXFwibGVmdCBjYXJvdXNlbC1jb250cm9sIGNhcm91c2VsLWNvbnRyb2wtcHJldlxcXCIgW2NsYXNzLmRpc2FibGVkXT1cXFwiYWN0aXZlU2xpZGUgPT09IDAgJiYgbm9XcmFwXFxcIiAoY2xpY2spPVxcXCJwcmV2aW91c1NsaWRlKClcXFwiICpuZ0lmPVxcXCJzbGlkZXMubGVuZ3RoID4gMVxcXCJcXG4gICAgICB0YWJpbmRleD1cXFwiMFxcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImljb24tcHJldiBjYXJvdXNlbC1jb250cm9sLXByZXYtaWNvblxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvc3Bhbj5cXG4gICAgPHNwYW4gKm5nSWY9XFxcImlzQnM0XFxcIiBjbGFzcz1cXFwic3Itb25seVxcXCI+UHJldmlvdXM8L3NwYW4+XFxuICA8L2E+XFxuICA8YSBjbGFzcz1cXFwicmlnaHQgY2Fyb3VzZWwtY29udHJvbCBjYXJvdXNlbC1jb250cm9sLW5leHRcXFwiIChjbGljayk9XFxcIm5leHRTbGlkZSgpXFxcIiBbY2xhc3MuZGlzYWJsZWRdPVxcXCJpc0xhc3QoYWN0aXZlU2xpZGUpICYmIG5vV3JhcFxcXCIgKm5nSWY9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIlxcbiAgICAgdGFiaW5kZXg9XFxcIjBcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLW5leHQgY2Fyb3VzZWwtY29udHJvbC1uZXh0LWljb25cXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L3NwYW4+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5OZXh0PC9zcGFuPlxcbiAgPC9hPlxcbjwvZGl2PlxcblwiXG4gICAgICAgICAgICAgICAgfV0gfVxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2Fyb3VzZWxDb25maWcgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgIG5vV3JhcDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIG5vUGF1c2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzaG93SW5kaWNhdG9yczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHBhdXNlT25Gb2N1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGluZGljYXRvcnNCeUNodW5rOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgaXRlbXNQZXJTbGlkZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHNpbmdsZVNsaWRlT2Zmc2V0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgYWN0aXZlU2xpZGVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICAgICAgc2xpZGVSYW5nZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgICAgICBhY3RpdmVTbGlkZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHN0YXJ0RnJvbUluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgaW50ZXJ2YWw6IFt7IHR5cGU6IElucHV0IH1dXG4gICAgfTtcbiAgICByZXR1cm4gQ2Fyb3VzZWxDb21wb25lbnQ7XG59KCkpO1xuZXhwb3J0IHsgQ2Fyb3VzZWxDb21wb25lbnQgfTtcbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUubm9XcmFwO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUubm9QYXVzZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLnNob3dJbmRpY2F0b3JzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUucGF1c2VPbkZvY3VzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuaW5kaWNhdG9yc0J5Q2h1bms7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5pdGVtc1BlclNsaWRlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuc2luZ2xlU2xpZGVPZmZzZXQ7XG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBlbWl0dGVkIHdoZW4gYWN0aXZlIHNsaWRlIGhhcyBiZWVuIGNoYW5nZWQuIFBhcnQgb2YgdHdvLXdheS1iaW5kYWJsZSBbKGFjdGl2ZVNsaWRlKV0gcHJvcGVydHlcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuYWN0aXZlU2xpZGVDaGFuZ2U7XG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBlbWl0dGVkIHdoZW4gYWN0aXZlIHNsaWRlcyBoYXMgYmVlbiBjaGFuZ2VkIGluIG11bHRpbGlzdCBtb2RlXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLnNsaWRlUmFuZ2VDaGFuZ2U7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5zdGFydEZyb21JbmRleDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRJbnRlcnZhbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLl9jdXJyZW50QWN0aXZlU2xpZGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5faW50ZXJ2YWw7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5fc2xpZGVzO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBDYXJvdXNlbENvbXBvbmVudC5wcm90b3R5cGUuX2NodW5rZWRTbGlkZXM7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5fc2xpZGVzV2l0aEluZGV4ZXM7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5fY3VycmVudFZpc2libGVTbGlkZXNJbmRleDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLmlzUGxheWluZztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3llZDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQ2Fyb3VzZWxDb21wb25lbnQucHJvdG90eXBlLmdldEFjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5tYWtlU2xpZGVzQ29uc2lzdGVudDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENhcm91c2VsQ29tcG9uZW50LnByb3RvdHlwZS5uZ1pvbmU7XG59XG4iXX0=